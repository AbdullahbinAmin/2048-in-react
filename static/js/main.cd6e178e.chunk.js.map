{"version":3,"sources":["components/Button/Button.tsx","components/Board/context/BoardContext.tsx","components/Board/hooks/useBoard.ts","styles/index.tsx","components/Board/models/Board.ts","components/Grid/Grid.tsx","components/Tile/Tile.tsx","hooks/usePrevProps.ts","components/Board/Board.tsx","components/Tile/models/Tile.ts","components/Game/hooks/useIds.ts","components/Game/hooks/useGame/reducer.ts","components/Game/hooks/useGame/useGame.ts","components/Game/Game.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Button","_ref","children","onClick","_jsx","className","BoardContext","React","createContext","containerWidth","tileCount","defaultTileCount","BoardProvider","Provider","value","useBoard","useContext","Grid","renderGrid","length","cells","index","push","concat","Tile","position","zIndex","scale","setScale","useState","previousValue","ref","useRef","useEffect","current","usePrevProps","withinBoardBoundaries","invariant","shallHighlight","undefined","setTimeout","positionToPixels","style","top","left","transform","Board","tiles","tileCountPerRow","tileWidth","boardWidth","tileList","map","_ref2","id","restProps","_objectWithoutProperties","_excluded","_objectSpread","width","_jsxs","seqId","initialState","byIds","hasChanged","inMotion","GameReducer","state","action","type","tile","_state$tiles","_action$source$id","source","_action$destination$i","destination","restTiles","_toPropertyKey","filter","useGame","isInitialRender","nextId","dispatch","useReducer","createTile","useCallback","throttledMergeTile","mergeTile","updateTile","didTileMove","hasXChanged","hasYChanged","retrieveTileMap","tileMap","Array","tileCountPerRowOrColumn","fill","forEach","positionToIndex","findEmptyTiles","reduce","result","tileId","indexToPosition","generateRandomTile","emptyTiles","Math","floor","random","move","retrieveTileIdsPerRowOrColumn","calculateFirstFreeIndex","maxIndex","rowOrColumnIndex","availableTileIds","previousTile","mergedTilesCount","nonEmptyTileIndex","currentTile","mergeWith","bind","rowIndex","tileIndex","tileInRowIndex","howManyMerges","_","reverse","maxIndexInRow","columnIndex","tileInColumnIndex","maxIndexInColumn","Game","moveLeft","moveRight","moveUp","moveDown","throttledHandleKeyDown","useThrottledCallback","e","preventDefault","code","leading","trailing","window","addEventListener","removeEventListener","App","date","setDate","Date","handleRestart","toISOString","href","target","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.cd6e178e.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./button.less\";\n\ntype Props = {\n  children: any;\n  onClick?: () => void;\n};\n\nexport const Button = ({ children, onClick }: Props) => {\n  return (\n    <button className=\"button\" onClick={onClick}>\n      {children}\n    </button>\n  );\n};\n","import React from \"react\";\nimport { tileCount as defaultTileCount } from \"../index\";\nexport const TILE_COUNT = 4; // Use a default value, e.g., 4 for a 4x4 board\n\nexport const BoardContext = React.createContext({\n  containerWidth: 0,\n  tileCount: defaultTileCount,\n});\n\ntype Props = {\n  containerWidth?: number;\n  tileCount?: number;\n  children: any;\n};\n\nexport const BoardProvider = ({\n  children,\n  containerWidth = 0,\n  tileCount = defaultTileCount,\n}: Props) => {\n  return (\n    <BoardContext.Provider value={{ containerWidth, tileCount }}>\n      {children}\n    </BoardContext.Provider>\n  );\n};","import { useContext } from \"react\";\nimport { BoardContext } from \"../context/BoardContext\";\n\n/**\n * Returns the properties of the board such as tile container width or tile count.\n */\nexport const useBoard = (): [number, number] => {\n  const { containerWidth, tileCount } = useContext(BoardContext);\n  return [containerWidth, tileCount];\n};\n","import \"./index.less\";\n\n/**\n * The pixel size of the grid.\n */\nexport const pixelSize = 8;\n","import { pixelSize } from \"../../../styles\";\n\n/**\n * The number of tiles per row and column.\n * IMPORTANT! Check styles before changing this value!\n *\n * @constant {number}\n */\nexport const tileCount = 4;\n\n/**\n * The duration of every animation in ms.\n * IMPORTANT! Check styles before modyfing this value!\n *\n * @constant {number} ms\n */\nexport const animationDuration = 250;\n\n/**\n * The board margin (left, right, top, bottom).\n */\nexport const boardMargin = 2 * pixelSize;\n","import React from \"react\";\nimport { useBoard } from \"../Board\";\n\nimport \"./grid.less\";\n\nexport const Grid = () => {\n  const [, tileCount] = useBoard();\n\n  const renderGrid = () => {\n    const length = tileCount * tileCount;\n    const cells = [] as JSX.Element[];\n\n    for (let index = 0; index < length; index += 1) {\n      cells.push(<div key={`${index}`} className={`grid-cell`} />);\n    }\n\n    return cells;\n  };\n\n  return <div className=\"grid\">{renderGrid()}</div>;\n};\n","import React, { useEffect, useState } from \"react\";\nimport invariant from \"tiny-invariant\";\nimport { usePrevProps } from \"../../hooks/usePrevProps\";\nimport { useBoard } from \"../Board\";\nimport \"./tile.less\";\n\ntype Props = {\n  // tile value - 2, 4, 8, 16, 32, ..., 2048.∂\n  value: number;\n  // an array containing the x and y index on the board.\n  position: [number, number];\n  // the order of tile on the tile stack.\n  zIndex: number;\n};\n\nexport const Tile = ({ value, position, zIndex }: Props) => {\n  // retrieves board properties\n  const [containerWidth, tileCount] = useBoard();\n  //  state required to animate the highlight\n  const [scale, setScale] = useState(1);\n\n  // the previous value (prop) - it is undefined if it is a new tile.\n  const previousValue = usePrevProps<number>(value);\n\n  // check if tile is within the board boundries\n  const withinBoardBoundaries =\n    position[0] < tileCount && position[1] < tileCount;\n  invariant(withinBoardBoundaries, \"Tile out of bound\");\n\n  // if it is a new tile...\n  const isNew = previousValue === undefined;\n  // ...or its value has changed...\n  const hasChanged = previousValue !== value;\n  // ... then the tile should be highlighted.\n  const shallHighlight = isNew || hasChanged;\n\n  // useEffect will decide if highlight should be triggered.\n  useEffect(() => {\n    if (shallHighlight) {\n      setScale(1.1);\n      setTimeout(() => setScale(1), 100);\n    }\n  }, [shallHighlight, scale]);\n\n  /**\n   * Converts tile position from array index to pixels.\n   */\n  const positionToPixels = (position: number) => {\n    return (position / tileCount) * (containerWidth as number);\n  };\n\n  // all animations come from CSS transition, and we pass them as styles\n  const style = {\n    top: positionToPixels(position[1]),\n    left: positionToPixels(position[0]),\n    transform: `scale(${scale})`,\n    zIndex,\n  };\n\n  return (\n    <div className={`tile tile-${value}`} style={style}>\n      {value}\n    </div>\n  );\n};\n","import { useEffect, useRef } from \"react\";\n\n/**\n * `usePrevProps` stores the previous value of the prop.\n *\n * @link https://blog.logrocket.com/how-to-get-previous-props-state-with-react-hooks/\n * @param {K} value\n * @returns {K | undefined}\n */\nexport const usePrevProps = <K = any>(value: K) => {\n  const ref = useRef<K>();\n\n  useEffect(() => {\n    ref.current = value;\n  });\n\n  return ref.current;\n};\n","import React from \"react\";\nimport { BoardProvider } from \"./context/BoardContext\";\nimport { boardMargin, tileCount as defaultTileCount } from \"./models/Board\";\nimport { Grid } from \"../Grid\";\nimport { TileMeta, tileTotalWidth, Tile } from \"../Tile\";\nimport \"./board.less\";\n\ntype Props = {\n  tiles: TileMeta[];\n  tileCountPerRow: number;\n};\n\nexport const Board = ({ tiles, tileCountPerRow = defaultTileCount }: Props) => {\n  // container width = tile width * tile count per row\n  const containerWidth = tileTotalWidth * tileCountPerRow;\n  // board width = container width + margin\n  const boardWidth = containerWidth + boardMargin;\n\n  // render all tiles on the board\n  const tileList = tiles.map(({ id, ...restProps }) => (\n    <Tile key={`tile-${id}`} {...restProps} zIndex={id} />\n  ));\n\n  return (\n    <div className=\"board\" style={{ width: boardWidth }}>\n      <BoardProvider\n        containerWidth={containerWidth}\n        tileCount={tileCountPerRow}\n      >\n        <div className=\"tile-container\">{tileList}</div>\n        <Grid />\n      </BoardProvider>\n    </div>\n  );\n};\n","import { pixelSize } from \"../../../styles\";\n\nexport type TileMeta = {\n  id: number;\n  position: [number, number];\n  value: number;\n  mergeWith?: number;\n};\n\nconst tileMargin = 2 * pixelSize;\n\nconst tileWidthMultiplier = 12.5;\n\nconst tileWidth = tileWidthMultiplier * pixelSize;\n\nexport const tileTotalWidth = tileWidth + tileMargin;\n","let seqId = 1;\n\n/**\n * Returns next sequential number.\n */\nexport const useIds = () => {\n  const nextId = () => {\n    return seqId++;\n  };\n\n  return [nextId];\n};\n","import { TileMeta } from \"../../../Tile\";\n\ntype State = {\n  tiles: {\n    [id: number]: TileMeta;\n  };\n  inMotion: boolean;\n  hasChanged: boolean;\n  byIds: number[];\n};\n\nexport const initialState: State = {\n  tiles: {},\n  byIds: [],\n  hasChanged: false,\n  inMotion: false,\n};\n\ntype Action =\n  | { type: \"CREATE_TILE\"; tile: TileMeta }\n  | { type: \"UPDATE_TILE\"; tile: TileMeta }\n  | { type: \"MERGE_TILE\"; source: TileMeta; destination: TileMeta }\n  | { type: \"START_MOVE\" }\n  | { type: \"END_MOVE\" };\n\nexport const GameReducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case \"CREATE_TILE\":\n      return {\n        ...state,\n        tiles: {\n          ...state.tiles,\n          [action.tile.id]: action.tile,\n        },\n        byIds: [...state.byIds, action.tile.id],\n        hasChanged: false,\n      };\n    case \"UPDATE_TILE\":\n      return {\n        ...state,\n        tiles: {\n          ...state.tiles,\n          [action.tile.id]: action.tile,\n        },\n        hasChanged: true,\n      };\n    case \"MERGE_TILE\":\n      const {\n        [action.source.id]: source,\n        [action.destination.id]: destination,\n        ...restTiles\n      } = state.tiles;\n      return {\n        ...state,\n        tiles: {\n          ...restTiles,\n          [action.destination.id]: {\n            id: action.destination.id,\n            value: action.source.value + action.destination.value,\n            position: action.destination.position,\n          },\n        },\n        byIds: state.byIds.filter((id) => id !== action.source.id),\n        hasChanged: true,\n      };\n    case \"START_MOVE\":\n      return {\n        ...state,\n        inMotion: true,\n      };\n    case \"END_MOVE\":\n      return {\n        ...state,\n        inMotion: false,\n      };\n    default:\n      return state;\n  }\n};\n","import { useCallback, useEffect, useReducer, useRef } from \"react\";\nimport {\n  animationDuration,\n  tileCount as tileCountPerRowOrColumn,\n} from \"../../../Board\";\nimport { TileMeta } from \"../../../Tile\";\nimport { useIds } from \"../useIds\";\nimport { GameReducer, initialState } from \"./reducer\";\n\nexport const useGame = () => {\n  const isInitialRender = useRef(true);\n  const [nextId] = useIds();\n  // state\n  const [state, dispatch] = useReducer(GameReducer, initialState);\n  const { tiles, byIds, hasChanged, inMotion } = state;\n\n  const createTile = useCallback(\n    ({ position, value }: Partial<TileMeta>) => {\n      const tile = {\n        id: nextId(),\n        position,\n        value,\n      } as TileMeta;\n      dispatch({ type: \"CREATE_TILE\", tile });\n    },\n    [nextId]\n  );\n\n  const mergeTile = (source: TileMeta, destination: TileMeta) => {\n    dispatch({ type: \"MERGE_TILE\", source, destination });\n  };\n\n  // A must-have to keep the sliding animation if the action merges tiles together.\n  const throttledMergeTile = (source: TileMeta, destination: TileMeta) => {\n    setTimeout(() => mergeTile(source, destination), animationDuration);\n  };\n\n  const updateTile = (tile: TileMeta) => {\n    dispatch({ type: \"UPDATE_TILE\", tile });\n  };\n\n  const didTileMove = (source: TileMeta, destination: TileMeta) => {\n    const hasXChanged = source.position[0] !== destination.position[0];\n    const hasYChanged = source.position[1] !== destination.position[1];\n\n    return hasXChanged || hasYChanged;\n  };\n\n  const retrieveTileMap = useCallback(() => {\n    const tileMap = new Array(\n      tileCountPerRowOrColumn * tileCountPerRowOrColumn\n    ).fill(0) as number[];\n\n    byIds.forEach((id) => {\n      const { position } = tiles[id];\n      const index = positionToIndex(position);\n      tileMap[index] = id;\n    });\n\n    return tileMap;\n  }, [byIds, tiles]);\n\n  const findEmptyTiles = useCallback(() => {\n    const tileMap = retrieveTileMap();\n\n    const emptyTiles = tileMap.reduce((result, tileId, index) => {\n      if (tileId === 0) {\n        return [...result, indexToPosition(index) as [number, number]];\n      }\n\n      return result;\n    }, [] as [number, number][]);\n\n    return emptyTiles;\n  }, [retrieveTileMap]);\n\n  const generateRandomTile = useCallback(() => {\n    const emptyTiles = findEmptyTiles();\n\n    if (emptyTiles.length > 0) {\n      const index = Math.floor(Math.random() * emptyTiles.length);\n      const position = emptyTiles[index];\n\n      createTile({ position, value: 2 });\n    }\n  }, [findEmptyTiles, createTile]);\n\n  const positionToIndex = (position: [number, number]) => {\n    return position[1] * tileCountPerRowOrColumn + position[0];\n  };\n\n  const indexToPosition = (index: number) => {\n    const x = index % tileCountPerRowOrColumn;\n    const y = Math.floor(index / tileCountPerRowOrColumn);\n    return [x, y];\n  };\n\n  type RetrieveTileIdsPerRowOrColumn = (rowOrColumnIndex: number) => number[];\n\n  type CalculateTileIndex = (\n    tileIndex: number,\n    tileInRowIndex: number,\n    howManyMerges: number,\n    maxIndexInRow: number\n  ) => number;\n\n  const move = (\n    retrieveTileIdsPerRowOrColumn: RetrieveTileIdsPerRowOrColumn,\n    calculateFirstFreeIndex: CalculateTileIndex\n  ) => {\n    // new tiles cannot be created during motion.\n    dispatch({ type: \"START_MOVE\" });\n\n    const maxIndex = tileCountPerRowOrColumn - 1;\n\n    // iterates through every row or column (depends on move kind - vertical or horizontal).\n    for (\n      let rowOrColumnIndex = 0;\n      rowOrColumnIndex < tileCountPerRowOrColumn;\n      rowOrColumnIndex += 1\n    ) {\n      // retrieves tiles in the row or column.\n      const availableTileIds = retrieveTileIdsPerRowOrColumn(rowOrColumnIndex);\n\n      // previousTile is used to determine if tile can be merged with the current tile.\n      let previousTile: TileMeta | undefined;\n      // mergeCount helps to fill gaps created by tile merges - two tiles become one.\n      let mergedTilesCount = 0;\n\n      // interate through available tiles.\n      availableTileIds.forEach((tileId, nonEmptyTileIndex) => {\n        const currentTile = tiles[tileId];\n\n        // if previous tile has the same value as the current one they should be merged together.\n        if (\n          previousTile !== undefined &&\n          previousTile.value === currentTile.value\n        ) {\n          const tile = {\n            ...currentTile,\n            position: previousTile.position,\n            mergeWith: previousTile.id,\n          } as TileMeta;\n\n          // delays the merge by 250ms, so the sliding animation can be completed.\n          throttledMergeTile(tile, previousTile);\n          // previous tile must be cleared as a single tile can be merged only once per move.\n          previousTile = undefined;\n          // increment the merged counter to correct position for the consecutive tiles to get rid of gaps\n          mergedTilesCount += 1;\n\n          return updateTile(tile);\n        }\n\n        // else - previous and current tiles are different - move the tile to the first free space.\n        const tile = {\n          ...currentTile,\n          position: indexToPosition(\n            calculateFirstFreeIndex(\n              rowOrColumnIndex,\n              nonEmptyTileIndex,\n              mergedTilesCount,\n              maxIndex\n            )\n          ),\n        } as TileMeta;\n\n        // previous tile become the current tile to check if the next tile can be merged with this one.\n        previousTile = tile;\n\n        // only if tile has changed its position it will be updated\n        if (didTileMove(currentTile, tile)) {\n          return updateTile(tile);\n        }\n      });\n    }\n\n    // wait until the end of all animations.\n    setTimeout(() => dispatch({ type: \"END_MOVE\" }), animationDuration);\n  };\n\n  const moveLeftFactory = () => {\n    const retrieveTileIdsByRow = (rowIndex: number) => {\n      const tileMap = retrieveTileMap();\n\n      const tileIdsInRow = [\n        tileMap[rowIndex * tileCountPerRowOrColumn + 0],\n        tileMap[rowIndex * tileCountPerRowOrColumn + 1],\n        tileMap[rowIndex * tileCountPerRowOrColumn + 2],\n        tileMap[rowIndex * tileCountPerRowOrColumn + 3],\n      ];\n\n      const nonEmptyTiles = tileIdsInRow.filter((id) => id !== 0);\n      return nonEmptyTiles;\n    };\n\n    const calculateFirstFreeIndex = (\n      tileIndex: number,\n      tileInRowIndex: number,\n      howManyMerges: number,\n      _: number\n    ) => {\n      return (\n        tileIndex * tileCountPerRowOrColumn + tileInRowIndex - howManyMerges\n      );\n    };\n\n    return move.bind(this, retrieveTileIdsByRow, calculateFirstFreeIndex);\n  };\n\n  const moveRightFactory = () => {\n    const retrieveTileIdsByRow = (rowIndex: number) => {\n      const tileMap = retrieveTileMap();\n\n      const tileIdsInRow = [\n        tileMap[rowIndex * tileCountPerRowOrColumn + 0],\n        tileMap[rowIndex * tileCountPerRowOrColumn + 1],\n        tileMap[rowIndex * tileCountPerRowOrColumn + 2],\n        tileMap[rowIndex * tileCountPerRowOrColumn + 3],\n      ];\n\n      const nonEmptyTiles = tileIdsInRow.filter((id) => id !== 0);\n      return nonEmptyTiles.reverse();\n    };\n\n    const calculateFirstFreeIndex = (\n      tileIndex: number,\n      tileInRowIndex: number,\n      howManyMerges: number,\n      maxIndexInRow: number\n    ) => {\n      return (\n        tileIndex * tileCountPerRowOrColumn +\n        maxIndexInRow +\n        howManyMerges -\n        tileInRowIndex\n      );\n    };\n\n    return move.bind(this, retrieveTileIdsByRow, calculateFirstFreeIndex);\n  };\n\n  const moveUpFactory = () => {\n    const retrieveTileIdsByColumn = (columnIndex: number) => {\n      const tileMap = retrieveTileMap();\n\n      const tileIdsInColumn = [\n        tileMap[columnIndex + tileCountPerRowOrColumn * 0],\n        tileMap[columnIndex + tileCountPerRowOrColumn * 1],\n        tileMap[columnIndex + tileCountPerRowOrColumn * 2],\n        tileMap[columnIndex + tileCountPerRowOrColumn * 3],\n      ];\n\n      const nonEmptyTiles = tileIdsInColumn.filter((id) => id !== 0);\n      return nonEmptyTiles;\n    };\n\n    const calculateFirstFreeIndex = (\n      tileIndex: number,\n      tileInColumnIndex: number,\n      howManyMerges: number,\n      _: number\n    ) => {\n      return (\n        tileIndex +\n        tileCountPerRowOrColumn * (tileInColumnIndex - howManyMerges)\n      );\n    };\n\n    return move.bind(this, retrieveTileIdsByColumn, calculateFirstFreeIndex);\n  };\n\n  const moveDownFactory = () => {\n    const retrieveTileIdsByColumn = (columnIndex: number) => {\n      const tileMap = retrieveTileMap();\n\n      const tileIdsInColumn = [\n        tileMap[columnIndex + tileCountPerRowOrColumn * 0],\n        tileMap[columnIndex + tileCountPerRowOrColumn * 1],\n        tileMap[columnIndex + tileCountPerRowOrColumn * 2],\n        tileMap[columnIndex + tileCountPerRowOrColumn * 3],\n      ];\n\n      const nonEmptyTiles = tileIdsInColumn.filter((id) => id !== 0);\n      return nonEmptyTiles.reverse();\n    };\n\n    const calculateFirstFreeIndex = (\n      tileIndex: number,\n      tileInColumnIndex: number,\n      howManyMerges: number,\n      maxIndexInColumn: number\n    ) => {\n      return (\n        tileIndex +\n        tileCountPerRowOrColumn *\n          (maxIndexInColumn - tileInColumnIndex + howManyMerges)\n      );\n    };\n\n    return move.bind(this, retrieveTileIdsByColumn, calculateFirstFreeIndex);\n  };\n\n  useEffect(() => {\n    if (isInitialRender.current) {\n      createTile({ position: [0, 1], value: 2 });\n      createTile({ position: [0, 2], value: 2 });\n      isInitialRender.current = false;\n      return;\n    }\n\n    if (!inMotion && hasChanged) {\n      generateRandomTile();\n    }\n  }, [hasChanged, inMotion, createTile, generateRandomTile]);\n\n  const tileList = byIds.map((tileId) => tiles[tileId]);\n\n  const moveLeft = moveLeftFactory();\n  const moveRight = moveRightFactory();\n  const moveUp = moveUpFactory();\n  const moveDown = moveDownFactory();\n\n  return [tileList, moveLeft, moveRight, moveUp, moveDown] as [\n    TileMeta[],\n    () => void,\n    () => void,\n    () => void,\n    () => void\n  ];\n};\n","import React, { useEffect } from \"react\";\nimport { useThrottledCallback } from \"use-debounce\";\n\nimport { useGame } from \"./hooks/useGame\";\nimport { Board, animationDuration, tileCount } from \"../Board\";\n\nexport const Game = () => {\n  const [tiles, moveLeft, moveRight, moveUp, moveDown] = useGame();\n\n  const handleKeyDown = (e: KeyboardEvent) => {\n    // disables page scrolling with keyboard arrows\n    e.preventDefault();\n\n    switch (e.code) {\n      case \"ArrowLeft\":\n        moveLeft();\n        break;\n      case \"ArrowRight\":\n        moveRight();\n        break;\n      case \"ArrowUp\":\n        moveUp();\n        break;\n      case \"ArrowDown\":\n        moveDown();\n        break;\n    }\n  };\n\n  // protects the reducer from being flooded with events.\n  const throttledHandleKeyDown = useThrottledCallback(\n    handleKeyDown,\n    animationDuration,\n    { leading: true, trailing: false }\n  );\n\n  useEffect(() => {\n    window.addEventListener(\"keydown\", throttledHandleKeyDown);\n\n    return () => {\n      window.removeEventListener(\"keydown\", throttledHandleKeyDown);\n    };\n  }, [throttledHandleKeyDown]);\n\n  return <Board tiles={tiles} tileCountPerRow={tileCount} />;\n};\n","import React, { useState } from \"react\";\nimport { Button } from \"./components/Button\";\nimport { Game } from \"./components/Game\";\n\nimport \"./App.less\";\n\n/* eslint-disable react/jsx-no-target-blank */\nexport const App = () => {\n  const [date, setDate] = useState<Date>(new Date());\n\n  const handleRestart = () => {\n    setDate(new Date());\n  };\n\n  return (\n    <div className=\"App\">\n      <div className=\"header\">\n        <div>\n          <h1>Play 2048</h1>\n        </div>\n        <div>\n          <Button onClick={handleRestart}>Restart</Button>\n        </div>\n      </div>\n      <Game key={date.toISOString()} />\n      <div>\n        <p>\n          <b>Wondering how was that built?</b> You can find a video tutorial and\n          code here:\n        </p>\n        <ul>\n          <li>\n            <a href=\"https://youtu.be/vI0QArPnkUc\" target=\"_blank\">\n              Tutorial (YouTube video)\n            </a>\n          </li>\n          <li>\n            <a\n              href=\"https://github.com/mateuszsokola/2048-in-react/\"\n              target=\"_blank\"\n            >\n              Source Code (Github)\n            </a>\n          </li>\n          <li>\n            <a\n              href=\"https://mateuszsokola.github.io/2048-animation-examples/\"\n              target=\"_blank\"\n            >\n              Animation Examples (Github Pages)\n            </a>\n          </li>\n        </ul>\n        <p>\n          This game (2048) was built using <b>React</b> and <b>TypeScript</b>.\n          The unique part of this example is animations. The animations in React\n          aren't that straightforward, so I hope you can learn something new\n          from it.\n        </p>\n      </div>\n      <div className=\"footer\">\n        Made with ❤️ by{\" \"}\n        <a\n          href=\"https://www.youtube.com/channel/UCJV16_5c4A0amyBZSI4yP6A\"\n          target=\"_blank\"\n        >\n          Matt Sokola\n        </a>\n      </div>\n    </div>\n  );\n};\n/* eslint-enable react/jsx-no-target-blank */\n","import { ReportHandler } from \"web-vitals\";\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { App } from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}